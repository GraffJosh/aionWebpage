<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Aion's Track</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="jpg.ico" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/2.1.2/gpx.min.js"></script>
  <style>
    html, body { height: 100%; margin: 0; }
    #map {height: 100%;width: 100%;}
        
    #trackPanel {
        position: absolute;
        top: 100px;
        left: 10px;
        z-index: 1000;
        font-family: sans-serif;
    }

    /* Style the button */
    #toggleTrackList {
        width: 100%;
        background: #ffffffee;
        border: none;
        padding: 8px 12px;
        font-size: 16px;
        border-radius: 8px 8px 0 0;
        box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        cursor: pointer;
    }

    /* Style the collapsible list */
    #trackList {
        max-height: 40vh;
        overflow-y: auto;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 0 0 10px 10px;
        padding: 10px;
        font-size: 14px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        display: block;
    }

    #trackList.hidden {
        display: none;
    }
    
    #trackControls {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
    }
    #trackControls button {
        flex: 1;
        margin: 0 2px;
        padding: 4px 8px;
        font-size: 13px;
        border: 1px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
    }


    .track-item {
        display: flex;
        align-items: center;
        gap: 6px;
        margin: 4px 0;
        cursor: pointer;
    }
    .track-item input[type="checkbox"] {
        margin: 0;
    }

    @media (min-width: 125px) {
      #trackList {
        width: 150px;
        left: 10px;
        right: auto;
      }
    }
  </style>
</head>
<body>
    <div id="trackPanel">
        <button id="toggleTrackList">☰ Tracks</button>
        <div id="trackList">
            <div id="trackControls">
                <button id="selectAll">Select All</button>
                <button id="clearAll">Clear All</button>
            </div>
            <div id="trackCheckboxes"><i>Loading GPX files...</i></div>
        </div>

    </div>

  <div id="map"></div>
    <script>

        // === 2. Globals ===
        const trackCheckboxesDiv = document.getElementById('trackList');
        const loadedTracks = {};
        const globalColorMap = {};
        const globalColorPalette = ['red', 'blue', 'green', 'orange', 'purple', 'teal', 'brown', 'pink', 'gray'];
        const globalColorIndex = { value: 0 };  // mutable wrapper so we can pass by reference
        const fallbackView = {
            center: [39.279545, -76.584707], // your preferred lat/lon
            zoom: 13
        };


        const GITHUB_USER = 'graffjosh';
        const GITHUB_REPO = 'aionWebpage'; // your GitHub repo name
        const GITHUB_BRANCH = 'main';         // or 'master'
        const GPX_DIRECTORY = 'gpxFiles';     // folder containing your .gpx files

        // 1. Set up the Leaflet map
        const map = L.map('map').setView(fallbackView.center, fallbackView.zoom);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Map data © OpenStreetMap contributors'
        }).addTo(map);
        L.tileLayer('http://tiles.openseamap.org/seamark/{z}/{x}/{y}.png', {
            attribution: 'Map data © openseamap contributors'
        }).addTo(map);

        // === 5. Get GPX file list from GitHub API ===
        async function fetchGpxFiles() {
            const url = `https://api.github.com/repos/${GITHUB_USER}/${GITHUB_REPO}/git/trees/${GITHUB_BRANCH}?recursive=1`;
            const response = await fetch(url);
            const data = await response.json();
            if (!data.tree) return [];

            return data.tree
                .filter(item => item.path.startsWith(GPX_DIRECTORY + '/') && item.path.endsWith('.gpx'))
                .map(item => item.path);
        }
        function createCheckbox(filename, autoLoad = false) {
            const id = `track-${filename.replace(/[^\w-]/g, '_')}`;

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.value = filename;
            checkbox.id = id;

            const label = document.createElement('label');
            label.setAttribute('for', id);
            label.textContent = ' ' + filename.split('/').pop(); // human-readable

            const wrapper = document.createElement('div');
            wrapper.classList.add('track-item');
            wrapper.appendChild(checkbox);
            wrapper.appendChild(label);
            trackCheckboxesDiv.appendChild(wrapper);

            checkbox.addEventListener('change', (e) => {
                const isChecked = e.target.checked;
                isChecked ? addTrackToMap(filename) : removeTrackFromMap(filename);

                // Collapse on mobile
                if (window.innerWidth < 600) {
                    trackCheckboxesDiv.classList.add('hidden');
                }
            });

            if (autoLoad) {
                checkbox.checked = true;
                checkbox.dispatchEvent(new Event('change'));
            }
        }


        // === 6. Load GPX file and color by date ===
        function addTrackToMap(filename) {
            const gpxLayer = new L.GPX(filename, {
                async: true,
                marker_options: { startIconUrl: null, endIconUrl: null }
            });

            gpxLayer.on('loaded', (e) => {
                fitMapToAllTracks();
                colorTrackByFile(gpxLayer, filename, globalColorMap, globalColorPalette, globalColorIndex);
            });

            gpxLayer.addTo(map);
            loadedTracks[filename] = gpxLayer;
        }

        // 8. Remove a GPX layer from the map
        function removeTrackFromMap(filename) {
            if (loadedTracks[filename]) {
                map.removeLayer(loadedTracks[filename]);
                delete loadedTracks[filename];
                fitMapToAllTracks();

                // If no tracks remain, reset to fallback location
                if (Object.keys(loadedTracks).length === 0) {
                map.setView(fallbackView.center, fallbackView.zoom);
                }
            }
        }


        function fitMapToAllTracks() {
            const layers = Object.values(loadedTracks);
            if (layers.length === 0) return;

            let combinedBounds = null;

            layers.forEach(layer => {
                const bounds = layer.getBounds();
                if (!combinedBounds) {
                combinedBounds = bounds;
                } else {
                combinedBounds.extend(bounds);
                }
            });

            if (combinedBounds) {
                map.fitBounds(combinedBounds, { padding: [20, 20] });
            }
        }

        // === 8. Assign color based on segment start date (shared across files) ===
        function colorTrackByFile(gpxLayer, filename, colorMap, palette, colorIndex) {
            const colorKey = filename.split('/').pop(); // just the file name

            if (!colorMap[colorKey]) {
                colorMap[colorKey] = palette[colorIndex.value % palette.length];
                colorIndex.value++;
            }

            const color = colorMap[colorKey];

            const gpxElement = gpxLayer.getLayers()[0];
            if (!gpxElement) return;

            gpxElement.eachLayer(layer => {
                if (layer.setStyle) {
                layer.setStyle({ color: color, weight: 4 });
                }
            });
        }

        
        // === 9. Load file list + show most recent on load ===
        fetchGpxFiles().then(files => {
            trackCheckboxesDiv.innerHTML = ''; // clear loading message

            if (files.length === 0) {
                trackCheckboxesDiv.innerHTML = '<i>No GPX files found.</i>';
                return;
            }

            // Sort by filename descending (assuming date encoded)
            files.sort().reverse();

            // Auto-load most recent
            createCheckbox(files[0], true);

            // Add rest
            for (let i = 1; i < files.length; i++) {
                createCheckbox(files[i]);
            }
        });

        document.getElementById('selectAll').addEventListener('click', () => {
            const checkboxes = trackCheckboxesDiv.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => {
                if (!cb.checked) {
                cb.checked = true;
                cb.dispatchEvent(new Event('change'));
                }
            });
        });

        document.getElementById('clearAll').addEventListener('click', () => {
            const checkboxes = trackCheckboxesDiv.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => {
                if (cb.checked) {
                cb.checked = false;
                cb.dispatchEvent(new Event('change'));
                }
            });
        });


        document.getElementById('toggleTrackList').addEventListener('click', () => {
            trackCheckboxesDiv.classList.toggle('hidden');
        });
    </script>

</body>
</html>
