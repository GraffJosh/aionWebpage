<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Aion's Track</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="jpg.ico" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/2.1.2/gpx.min.js"></script>
  <style>
    html, body { height: 100%; margin: 0; }
    #map {height: 100%;width: 100%;}
        
    #trackPanel {
        position: absolute;
        top: 100px;
        left: 10px;
        z-index: 1000;
        font-family: sans-serif;
    }

    /* Style the button */
    #toggleTrackList {
        width: 100%;
        background: #ffffffee;
        border: none;
        padding: 8px 12px;
        font-size: 16px;
        border-radius: 8px 8px 0 0;
        box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        cursor: pointer;
    }

    /* Style the collapsible list */
    #trackList {
        max-height: 40vh;
        overflow-y: auto;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 0 0 10px 10px;
        padding: 10px;
        font-size: 14px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        display: block;
    }

    @media (min-width: 125px) {
      #trackList {
        left: 10px;
        right: auto;
      }
    }
    #trackList.hidden {
        display: none;
    }
    
    #trackControls {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
    }
    #trackControls button {
        flex: 1;
        margin: 0 2px;
        padding: 4px 8px;
        font-size: 13px;
        border: 1px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
    }


    .track-item {
        display: flex;
        align-items: center;
        gap: 6px;
        margin: 4px 0;
        cursor: pointer;
    }
    .track-item input[type="checkbox"],
    .folder-checkbox {
        transform: scale(1.4);
        margin-right: 6px;
    }
    @media (max-width: 600px) {
      .track-item input[type="checkbox"],
      .folder-checkbox {
        transform: scale(1.8);
      }
    }
    @media (min-width: 1200px) {
      .track-item input[type="checkbox"],
      .folder-checkbox {
        transform: scale(1.2);
      }
    }
    .track-folder {
        margin-bottom: 10px;
    }
    .folder {
        margin-bottom: 8px;
        border-radius: 8px;
        overflow: hidden;
        background: #f9f9f9;
        border: 1px solid #ddd;
    }

    .folder-header {
        display: flex;
        align-items: center;
        padding: 6px 10px;
        background: #f0f0f0;
        cursor: pointer;
        font-weight: bold;
        gap: 6px;
    }

    .folder-label {
        flex: 1;
    }

    .folder-checkbox {
        margin-left: auto;
    }

    .toggle-icon {
        width: 16px;
        text-align: center;
    }

    .sublist {
        display: none;
        padding: 6px 10px;
        border-top: 1px solid #ddd;
        background: #ffffff;
    }

    .sublist.expanded {
        display: block;
    }

    .folder-toggle {
        background: #f0f0f0;
        border: none;
        padding: 5px 8px;
        font-weight: bold;
        cursor: pointer;
        width: 100%;
        text-align: left;
        border-radius: 5px;
    }

    .folder-files {
        padding-left: 10px;
    }

  </style>
</head>
<body>
    <div id="trackPanel">
        <button id="toggleTrackList">☰ Tracks</button>
        <div id="trackList">
            <div id="trackControls">
                <button id="selectAll">Select All</button>
                <button id="clearAll">Clear All</button>
            </div>
            <div id="trackCheckboxes"><i>Loading GPX files...</i></div>
        </div>

    </div>

  <div id="map"></div>
    <script>

        // === 2. Globals ===
        const trackListDiv = document.getElementById('trackList');
        const trackCheckboxesDiv = document.getElementById('trackCheckboxes');
        const loadedTracks = {};
        const globalColorMap = {};
        const globalColorPalette = ['red', 'blue', 'green', 'orange', 'purple', 'teal', 'brown', 'pink', 'gray'];
        const globalColorIndex = { value: 0 };  // mutable wrapper so we can pass by reference
        const fallbackView = {
            center: [39.279545, -76.584707], // your preferred lat/lon
            zoom: 13
        };


        const GITHUB_USER = 'graffjosh';
        const GITHUB_REPO = 'aionWebpage'; // your GitHub repo name
        const GITHUB_BRANCH = 'main';         // or 'master'
        const GPX_DIRECTORY = 'gpxFiles';     // folder containing your .gpx files

        // 1. Set up the Leaflet map
        const map = L.map('map').setView(fallbackView.center, fallbackView.zoom);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Map data © OpenStreetMap contributors'
        }).addTo(map);
        L.tileLayer('http://tiles.openseamap.org/seamark/{z}/{x}/{y}.png', {
            attribution: 'Map data © openseamap contributors'
        }).addTo(map);

        async function fetchGroupedGpxFiles() {
            const url = `https://api.github.com/repos/${GITHUB_USER}/${GITHUB_REPO}/git/trees/${GITHUB_BRANCH}?recursive=1`;
            const response = await fetch(url);
            const data = await response.json();
            if (!data.tree) return {};

            // Group by subdirectory inside gpxFiles/
            const groups = {};

            data.tree.forEach(item => {
                if (
                    item.path.startsWith(GPX_DIRECTORY + '/') &&
                    item.path.endsWith('.gpx')
                ) {
                    const relativePath = item.path.slice(GPX_DIRECTORY.length + 1); // strip gpxFiles/
                    const parts = relativePath.split('/');
                    const folder = parts.length > 1 ? parts[0] : '_root';
                    if (!groups[folder]) groups[folder] = [];
                    groups[folder].push(item.path); // full path with gpxFiles/
                }
            });

            return groups;  // { folder1: [...], folder2: [...], _root: [...] }
        }

        
        let isBulkUpdatingFolders = false;
        function createGroupedUI(fileGroups) {
            trackCheckboxesDiv.innerHTML = ''; // Clear existing content

            Object.entries(fileGroups).forEach(([folderName, files]) => {
                const folderDiv = document.createElement('div');
                folderDiv.classList.add('folder');

                const folderHeader = document.createElement('div');
                folderHeader.classList.add('folder-header');

                const toggleIcon = document.createElement('span');
                toggleIcon.textContent = '▸';
                toggleIcon.className = 'toggle-icon';

                const folderLabel = document.createElement('span');
                folderLabel.textContent = folderName === '_root' ? 'Main Folder' : folderName;
                folderLabel.className = 'folder-label';

                const folderCheckbox = document.createElement('input');
                folderCheckbox.type = 'checkbox';
                folderCheckbox.className = 'folder-checkbox';
                folderCheckbox.title = 'Toggle all tracks in this folder';

                folderHeader.append(toggleIcon, folderLabel, folderCheckbox);
                folderDiv.appendChild(folderHeader);

                const subList = document.createElement('div');
                subList.className = 'sublist';

                const childCheckboxes = [];

                files.forEach(file => {
                    const checkboxWrapper = createCheckbox(file);
                    const checkbox = checkboxWrapper.querySelector('input[type="checkbox"]');
                    subList.appendChild(checkboxWrapper);
                    childCheckboxes.push(checkbox);

                    checkbox.addEventListener('change', () => {
                        if (!isBulkUpdatingFolders) {
                            const anyChecked = childCheckboxes.some(cb => cb.checked);
                            folderCheckbox.checked = anyChecked;
                        }
                    });
                });

                folderCheckbox.addEventListener('change', () => {
                    isBulkUpdatingFolders = true;
                    childCheckboxes.forEach(cb => {
                        if (cb.checked !== folderCheckbox.checked) {
                            cb.checked = folderCheckbox.checked;
                            cb.dispatchEvent(new Event('change'));
                        }
                    });
                    isBulkUpdatingFolders = false;
                });

                folderHeader.addEventListener('click', (e) => {
                    if (e.target === folderCheckbox) return;
                    const isExpanded = subList.classList.toggle('expanded');
                    toggleIcon.textContent = isExpanded ? '▾' : '▸';
                });

                folderDiv.appendChild(subList);
                trackCheckboxesDiv.appendChild(folderDiv);
            });
        }


        function createCheckbox(filename, autoLoad = false) {
            const id = `track-${filename.replace(/[^\w-]/g, '_')}`;

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.value = filename;
            checkbox.id = id;

            const label = document.createElement('label');
            label.setAttribute('for', id);
            label.textContent = ' ' + filename.split('/').pop();

            const wrapper = document.createElement('div');
            wrapper.classList.add('track-item');
            wrapper.appendChild(checkbox);
            wrapper.appendChild(label);

            checkbox.addEventListener('change', (e) => {
                const isChecked = e.target.checked;
                isChecked ? addTrackToMap(filename) : removeTrackFromMap(filename);

                if (window.innerWidth < 600) {
                trackListDiv.classList.add('hidden');
                }
            });

            if (autoLoad) {
                checkbox.checked = true;
                checkbox.dispatchEvent(new Event('change'));
            }

            return wrapper;
        }



        // === 6. Load GPX file and color by date ===
        function addTrackToMap(filename) {
            const gpxLayer = new L.GPX(filename, {
                async: true,
                marker_options: { startIconUrl: null, endIconUrl: null }
            });

            gpxLayer.on('loaded', (e) => {
                fitMapToAllTracks();
                colorTrackByFile(gpxLayer, filename, globalColorMap, globalColorPalette, globalColorIndex);
            });

            gpxLayer.addTo(map);
            loadedTracks[filename] = gpxLayer;
        }

        // 8. Remove a GPX layer from the map
        function removeTrackFromMap(filename) {
            if (loadedTracks[filename]) {
                map.removeLayer(loadedTracks[filename]);
                delete loadedTracks[filename];
                fitMapToAllTracks();

                // If no tracks remain, reset to fallback location
                if (Object.keys(loadedTracks).length === 0) {
                map.setView(fallbackView.center, fallbackView.zoom);
                }
            }
        }


        function fitMapToAllTracks() {
            const layers = Object.values(loadedTracks);
            if (layers.length === 0) return;

            let combinedBounds = null;

            layers.forEach(layer => {
                const bounds = layer.getBounds();
                if (!combinedBounds) {
                combinedBounds = bounds;
                } else {
                combinedBounds.extend(bounds);
                }
            });

            if (combinedBounds) {
                map.fitBounds(combinedBounds, { padding: [20, 20] });
            }
        }

        // === 8. Assign color based on segment start date (shared across files) ===
        function colorTrackByFile(gpxLayer, filename, colorMap, palette, colorIndex) {
            const colorKey = filename.split('/').pop(); // just the file name

            if (!colorMap[colorKey]) {
                colorMap[colorKey] = palette[colorIndex.value % palette.length];
                colorIndex.value++;
            }

            const color = colorMap[colorKey];

            const gpxElement = gpxLayer.getLayers()[0];
            if (!gpxElement) return;

            gpxElement.eachLayer(layer => {
                if (layer.setStyle) {
                layer.setStyle({ color: color, weight: 4 });
                }
            });
        }

        // Helper: Fetch first point date from a GPX file
        async function getGpxFirstDate(gpxPath) {
            const rawUrl = `https://raw.githubusercontent.com/${GITHUB_USER}/${GITHUB_REPO}/${GITHUB_BRANCH}/${gpxPath}`;
            try {
                const res = await fetch(rawUrl);
                const text = await res.text();
                const match = text.match(/<time>([^<]+)<\/time>/);
                if (match) return new Date(match[1]);
            } catch {}
            return new Date(0); // fallback
        }

        // Sort files in each folder by date
        async function sortGroupedFilesByDate(fileGroups) {
            for (const folder in fileGroups) {
                const files = fileGroups[folder];
                const filesWithDates = await Promise.all(
                    files.map(async file => ({
                        file,
                        date: await getGpxFirstDate(file)
                    }))
                );
                filesWithDates.sort((a, b) => a.date - b.date);
                fileGroups[folder] = filesWithDates.map(f => f.file);
            }
        }

        fetchGroupedGpxFiles().then(async fileGroups => {
            if (Object.keys(fileGroups).length === 0) {
                trackCheckboxesDiv.innerHTML = '<i>No GPX files found.</i>';
                return;
            }
            await sortGroupedFilesByDate(fileGroups);
            createGroupedUI(fileGroups);
            // Auto-select most recent file in all folders
            const allFiles = Object.values(fileGroups).flat();
            if (allFiles.length) {
                const first = allFiles.sort().reverse()[0];
                const checkbox = document.querySelector(`input[value="${first}"]`);
                if (checkbox) {
                    checkbox.checked = true;
                    checkbox.dispatchEvent(new Event('change'));
                }
            }
        });


        document.getElementById('selectAll').addEventListener('click', () => {
            const checkboxes = trackListDiv.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => {
                if (!cb.checked) {
                    cb.checked = true;
                    cb.dispatchEvent(new Event('change'));
                }
            });
        });

        document.getElementById('clearAll').addEventListener('click', () => {
            const checkboxes = trackListDiv.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => {
                if (cb.checked) {
                cb.checked = false;
                cb.dispatchEvent(new Event('change'));
                }
            });
        });


        document.getElementById('toggleTrackList').addEventListener('click', () => {
            trackListDiv.classList.toggle('hidden');
        });
    </script>

</body>
</html>
